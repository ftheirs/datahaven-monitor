name: Monitor ‚Äì Testnet Sentinel

on:
  schedule:
    # Run every 15 minutes
    - cron: "*/15 * * * *"
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  monitor:
    name: Run Testnet Sentinel
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run monitor
        env:
          ACCOUNT_PRIVATE_KEY: ${{ secrets.ACCOUNT_PRIVATE_KEY }}
          DATAHAVEN_NETWORK: testnet
          MONITOR_OUTPUT_DIR: badges
        run: bun run monitor

      - name: Publish badge endpoints to gh-pages
        if: always()
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: badges
          keep_files: false

      - name: Download previous status from GitHub Pages
        if: always()
        continue-on-error: true
        run: |
          echo "Downloading previous monitor status from GitHub Pages..."
          curl -f -o previous-monitor-status.json \
            https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/monitor-status.json \
            || echo "No previous status found (this might be the first run)"

      - name: Parse monitor status and detect changes
        if: always()
        id: parse_status
        run: |
          # Parse the detailed monitor status
          if [ ! -f badges/monitor-status.json ]; then
            echo "monitor-status.json not found"
            exit 0
          fi

          # Show what we have
          echo "=== Current Monitor Status ==="
          cat badges/monitor-status.json
          echo "=============================="

          # Extract current status
          CURRENT_OVERALL=$(jq -r '.overall' badges/monitor-status.json)
          PASSED=$(jq -r '.summary.passed' badges/monitor-status.json)
          FAILED=$(jq -r '.summary.failed' badges/monitor-status.json)
          SKIPPED=$(jq -r '.summary.skipped' badges/monitor-status.json)
          TOTAL=$(jq -r '.summary.total' badges/monitor-status.json)
          
          # Get failed stages
          FAILED_STAGES=$(jq -r '.stages[] | select(.status == "failed") | .name' badges/monitor-status.json | tr '\n' ',' | sed 's/,$//')
          
          # Get passed stages
          PASSED_STAGES=$(jq -r '.stages[] | select(.status == "passed") | .name' badges/monitor-status.json | tr '\n' ',' | sed 's/,$//')

          # Extract previous status if it exists
          PREVIOUS_OVERALL="unknown"
          STATUS_CHANGED="true"  # Default to true (notify on first run)
          CHANGE_TYPE="initial"
          
          if [ -f previous-monitor-status.json ] && [ -s previous-monitor-status.json ]; then
            echo ""
            echo "=== Previous Monitor Status ==="
            cat previous-monitor-status.json
            echo "==============================="
            echo ""
            
            PREVIOUS_OVERALL=$(jq -r '.overall' previous-monitor-status.json 2>/dev/null || echo "unknown")
            
            # Compare statuses
            if [ "$CURRENT_OVERALL" = "$PREVIOUS_OVERALL" ]; then
              STATUS_CHANGED="false"
              echo "‚úì Status unchanged: $CURRENT_OVERALL"
            else
              STATUS_CHANGED="true"
              if [ "$PREVIOUS_OVERALL" = "success" ] && [ "$CURRENT_OVERALL" = "failed" ]; then
                CHANGE_TYPE="degraded"
                echo "‚ö†Ô∏è Status degraded: success ‚Üí failed"
              elif [ "$PREVIOUS_OVERALL" = "failed" ] && [ "$CURRENT_OVERALL" = "success" ]; then
                CHANGE_TYPE="recovered"
                echo "‚úì Status recovered: failed ‚Üí success"
              else
                CHANGE_TYPE="changed"
                echo "‚ÑπÔ∏è Status changed: $PREVIOUS_OVERALL ‚Üí $CURRENT_OVERALL"
              fi
            fi
          else
            echo "‚ÑπÔ∏è No previous status found - this is the first run or initial setup"
          fi

          # Output all variables
          echo "overall=$CURRENT_OVERALL" >> $GITHUB_OUTPUT
          echo "previous_overall=$PREVIOUS_OVERALL" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "failed_stages=$FAILED_STAGES" >> $GITHUB_OUTPUT
          echo "passed_stages=$PASSED_STAGES" >> $GITHUB_OUTPUT
          echo "status_changed=$STATUS_CHANGED" >> $GITHUB_OUTPUT
          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT

      - name: Send Slack notification
        if: always() && steps.parse_status.outputs.status_changed == 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          OVERALL: ${{ steps.parse_status.outputs.overall }}
          PREVIOUS_OVERALL: ${{ steps.parse_status.outputs.previous_overall }}
          CHANGE_TYPE: ${{ steps.parse_status.outputs.change_type }}
          PASSED: ${{ steps.parse_status.outputs.passed }}
          FAILED: ${{ steps.parse_status.outputs.failed }}
          SKIPPED: ${{ steps.parse_status.outputs.skipped }}
          TOTAL: ${{ steps.parse_status.outputs.total }}
          FAILED_STAGES: ${{ steps.parse_status.outputs.failed_stages }}
          PASSED_STAGES: ${{ steps.parse_status.outputs.passed_stages }}
        run: |
          # Skip if webhook URL is not configured
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not configured, skipping notification"
            exit 0
          fi

          # Skip if status wasn't parsed (monitor didn't run)
          if [ -z "$OVERALL" ]; then
            echo "No monitor status to report"
            exit 0
          fi
          
          echo "üì¢ Status changed! Sending Slack notification..."
          echo "   Previous: $PREVIOUS_OVERALL"
          echo "   Current: $OVERALL"
          echo "   Change type: $CHANGE_TYPE"

          # Determine emoji, color, and title based on change type
          if [ "$CHANGE_TYPE" = "recovered" ]; then
            EMOJI="üü¢"
            COLOR="good"
            TITLE="Status Recovered - All Checks Passed"
          elif [ "$CHANGE_TYPE" = "degraded" ]; then
            EMOJI="üî¥"
            COLOR="danger"
            TITLE="Status Degraded - Checks Failed"
          elif [ "$CHANGE_TYPE" = "initial" ]; then
            if [ "$OVERALL" = "success" ]; then
              EMOJI="‚úÖ"
              COLOR="good"
              TITLE="Monitor Started - All Checks Passed"
            else
              EMOJI="‚ùå"
              COLOR="danger"
              TITLE="Monitor Started - Some Checks Failed"
            fi
          else
            # Generic change
            if [ "$OVERALL" = "success" ]; then
              EMOJI="‚úÖ"
              COLOR="good"
              TITLE="All Checks Passed"
            else
              EMOJI="‚ùå"
              COLOR="danger"
              TITLE="Some Checks Failed"
            fi
          fi

          # Build summary
          SUMMARY="üìä Status: $PASSED/$TOTAL passed"
          if [ "$FAILED" != "0" ]; then
            SUMMARY="$SUMMARY, $FAILED failed"
          fi
          if [ "$SKIPPED" != "0" ]; then
            SUMMARY="$SUMMARY, $SKIPPED skipped"
          fi

          # Build stage grid (3 columns)
          # Parse all stages from monitor-status.json
          STAGES_JSON=$(cat badges/monitor-status.json | jq -c '.stages[]')
          
          GRID=""
          COL_COUNT=0
          
          echo "$STAGES_JSON" | while IFS= read -r stage; do
            NAME=$(echo "$stage" | jq -r '.name')
            STATUS=$(echo "$stage" | jq -r '.status')
            
            # Format stage name (capitalize and add spaces)
            DISPLAY_NAME=$(echo "$NAME" | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
            
            # Add appropriate icon
            if [ "$STATUS" = "passed" ]; then
              ICON="‚úì"
            elif [ "$STATUS" = "failed" ]; then
              ICON="‚úó"
            else
              ICON="‚óã"
            fi
            
            # Pad name to ~15 chars for alignment
            printf -v PADDED_NAME "%-15s" "$DISPLAY_NAME"
            
            GRID="$GRID$ICON $PADDED_NAME"
            COL_COUNT=$((COL_COUNT + 1))
            
            # New row after 3 columns
            if [ $COL_COUNT -eq 3 ]; then
              GRID="$GRID\n"
              COL_COUNT=0
            else
              GRID="$GRID "
            fi
          done > /tmp/stage_grid.txt
          
          GRID=$(cat /tmp/stage_grid.txt)
          
          # If we have detailed monitor status, use the grid
          if [ -s badges/monitor-status.json ]; then
            # Create grid manually from known stages
            GRID=""
            for stage_name in connection health auth bucket-create storage-request file-upload file-download file-delete bucket-delete; do
              # Check if stage passed or failed
              stage_status=$(jq -r ".stages[] | select(.name == \"$stage_name\") | .status" badges/monitor-status.json 2>/dev/null)
              
              if [ "$stage_status" = "passed" ]; then
                icon="‚úì"
              elif [ "$stage_status" = "failed" ]; then
                icon="‚úó"
              else
                icon="‚óã"
              fi
              
              # Format display name
              case "$stage_name" in
                "connection") display="Connection   " ;;
                "health") display="Health       " ;;
                "auth") display="Auth         " ;;
                "bucket-create") display="Bucket Create" ;;
                "storage-request") display="Storage Req  " ;;
                "file-upload") display="File Upload  " ;;
                "file-download") display="File Download" ;;
                "file-delete") display="File Delete  " ;;
                "bucket-delete") display="Bucket Delete" ;;
              esac
              
              GRID="${GRID}${icon} ${display}    "
              
              # Add newline after every 3 stages
              case "$stage_name" in
                "auth"|"file-upload"|"bucket-delete") GRID="${GRID}\n" ;;
              esac
            done
          else
            # Fallback to simple list if no detailed status
            GRID="‚úÖ *Passed:* $PASSED_STAGES"
            if [ -n "$FAILED_STAGES" ]; then
              GRID="$GRID\n‚ùå *Failed:* $FAILED_STAGES"
            fi
          fi

          # Send to Slack
          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d "{
              \"text\": \"$EMOJI Testnet Sentinel - $TITLE\",
              \"attachments\": [
                {
                  \"color\": \"$COLOR\",
                  \"fields\": [
                    {
                      \"title\": \"Summary\",
                      \"value\": \"$SUMMARY\",
                      \"short\": false
                    },
                    {
                      \"title\": \"Stage Results\",
                      \"value\": \"$GRID\",
                      \"short\": false
                    },
                    {
                      \"title\": \"Info\",
                      \"value\": \"Network: Stagenet | <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View on GitHub>\",
                      \"short\": false
                    }
                  ],
                  \"footer\": \"Testnet Sentinel\",
                  \"ts\": $(date +%s)
                }
              ]
            }"

      - name: Fail if any stage failed
        if: always()
        run: |
          if [ -f badges/status.json ]; then
            if grep -q '"failed"' badges/status.json; then
              echo "One or more stages failed"
              exit 1
            fi
          fi


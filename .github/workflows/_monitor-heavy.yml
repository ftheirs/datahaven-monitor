name: _Monitor Heavy (reusable)

on:
  workflow_call:
    inputs:
      network:
        description: "StorageHub network name (e.g. stagenet|testnet)"
        type: string
        required: true
      publish_subdir:
        description: "Destination directory inside gh-pages (e.g. heavy/testnet)"
        type: string
        required: true
      output_dir:
        description: "Local output directory for monitor-heavy (e.g. badges-heavy/testnet)"
        type: string
        required: true
      slack_enabled:
        description: "Whether to send Slack notifications on status toggle"
        type: boolean
        required: false
        default: true
    secrets:
      ACCOUNT_PRIVATE_KEY:
        required: true
      SLACK_WEBHOOK_URL:
        required: false

permissions:
  contents: write

concurrency:
  group: monitor-heavy-${{ inputs.network }}
  cancel-in-progress: true

jobs:
  monitor_heavy:
    name: Run Monitor Heavy (${{ inputs.network }})
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run monitor-heavy
        env:
          ACCOUNT_PRIVATE_KEY: ${{ secrets.ACCOUNT_PRIVATE_KEY }}
          DATAHAVEN_NETWORK: ${{ inputs.network }}
          MONITOR_OUTPUT_DIR: ${{ inputs.output_dir }}
        run: bun run monitor-heavy

      - name: Download previous monitor-heavy status from gh-pages branch
        if: always()
        continue-on-error: true
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
          fetch-depth: 1

      - name: Publish monitor-heavy endpoints to gh-pages
        if: always()
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ${{ inputs.output_dir }}
          destination_dir: ${{ inputs.publish_subdir }}
          keep_files: true

      - name: Parse monitor-heavy status and detect changes
        if: always()
        id: parse_status
        env:
          OUTPUT_DIR: ${{ inputs.output_dir }}
          PUBLISH_SUBDIR: ${{ inputs.publish_subdir }}
        run: |
          CURRENT_PATH="${OUTPUT_DIR}/monitor-heavy-status.json"
          if [ ! -f "$CURRENT_PATH" ]; then
            echo "monitor-heavy-status.json not found at $CURRENT_PATH"
            exit 0
          fi

          echo "=== Current Monitor Heavy Status (${OUTPUT_DIR}) ==="
          cat "$CURRENT_PATH"
          echo "==================================================="

          CURRENT_OVERALL=$(jq -r '.overall' "$CURRENT_PATH")
          CURRENT_NETWORK=$(jq -r '.network' "$CURRENT_PATH")
          CURRENT_DURATION_MS=$(jq -r '.summary.durationMs' "$CURRENT_PATH")
          CURRENT_DURATION_S=$((CURRENT_DURATION_MS / 1000))

          FAILED_PHASES=$(jq -r '.phases[] | select(.status == "failed") | .label' "$CURRENT_PATH" | tr '\n' ',' | sed 's/,$//')
          PASSED=$(jq -r '[.phases[] | select(.status == "passed")] | length' "$CURRENT_PATH")
          FAILED=$(jq -r '[.phases[] | select(.status == "failed")] | length' "$CURRENT_PATH")
          TOTAL=$(jq -r '.phases | length' "$CURRENT_PATH")

          PREVIOUS_OVERALL="unknown"
          PREVIOUS_VALID="false"
          STATUS_CHANGED="false"
          CHANGE_TYPE="unchanged"

          PREVIOUS_PATH="gh-pages/${PUBLISH_SUBDIR}/monitor-heavy-status.json"
          if [ -f "$PREVIOUS_PATH" ] && [ -s "$PREVIOUS_PATH" ]; then
            PREVIOUS_OVERALL=$(jq -er '.overall' "$PREVIOUS_PATH" 2>/dev/null || echo "")
            if [ "$PREVIOUS_OVERALL" = "success" ] || [ "$PREVIOUS_OVERALL" = "failed" ]; then
              PREVIOUS_VALID="true"
            fi
          fi

          if [ "$PREVIOUS_VALID" = "true" ]; then
            if [ "$CURRENT_OVERALL" = "$PREVIOUS_OVERALL" ]; then
              STATUS_CHANGED="false"
              echo "âœ“ Status unchanged: $CURRENT_OVERALL"
            else
              STATUS_CHANGED="true"
              if [ "$PREVIOUS_OVERALL" = "success" ] && [ "$CURRENT_OVERALL" = "failed" ]; then
                CHANGE_TYPE="degraded"
              elif [ "$PREVIOUS_OVERALL" = "failed" ] && [ "$CURRENT_OVERALL" = "success" ]; then
                CHANGE_TYPE="recovered"
              else
                CHANGE_TYPE="changed"
              fi
              echo "â„¹ï¸ Status changed: $PREVIOUS_OVERALL â†’ $CURRENT_OVERALL ($CHANGE_TYPE)"
            fi
          else
            if [ -f "$PREVIOUS_PATH" ] && [ -s "$PREVIOUS_PATH" ]; then
              STATUS_CHANGED="false"
              CHANGE_TYPE="invalid_previous"
              echo "âš ï¸ Previous status exists but is invalid/unparsable; skipping Slack notification"
            else
              CHANGE_TYPE="no_previous"
              echo "â„¹ï¸ No valid previous status found; skipping Slack notification"
            fi
          fi

          echo "overall=$CURRENT_OVERALL" >> $GITHUB_OUTPUT
          echo "previous_overall=$PREVIOUS_OVERALL" >> $GITHUB_OUTPUT
          echo "network=$CURRENT_NETWORK" >> $GITHUB_OUTPUT
          echo "duration_s=$CURRENT_DURATION_S" >> $GITHUB_OUTPUT
          echo "failed_phases=$FAILED_PHASES" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "status_changed=$STATUS_CHANGED" >> $GITHUB_OUTPUT
          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT

      - name: Send Slack notification (monitor-heavy)
        if: always() && inputs.slack_enabled && steps.parse_status.outputs.status_changed == 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          OVERALL: ${{ steps.parse_status.outputs.overall }}
          PREVIOUS_OVERALL: ${{ steps.parse_status.outputs.previous_overall }}
          CHANGE_TYPE: ${{ steps.parse_status.outputs.change_type }}
          NETWORK: ${{ steps.parse_status.outputs.network }}
          DURATION_S: ${{ steps.parse_status.outputs.duration_s }}
          FAILED_PHASES: ${{ steps.parse_status.outputs.failed_phases }}
          PASSED: ${{ steps.parse_status.outputs.passed }}
          FAILED: ${{ steps.parse_status.outputs.failed }}
          TOTAL: ${{ steps.parse_status.outputs.total }}
          OUTPUT_DIR: ${{ inputs.output_dir }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not configured, skipping notification"
            exit 0
          fi
          if [ -z "$OVERALL" ]; then
            echo "No monitor-heavy status to report"
            exit 0
          fi

          if [ "$CHANGE_TYPE" = "recovered" ]; then
            EMOJI="ðŸŸ¢"
            COLOR="good"
            TITLE="Recovered"
          elif [ "$CHANGE_TYPE" = "degraded" ]; then
            EMOJI="ðŸ”´"
            COLOR="danger"
            TITLE="Degraded"
          else
            if [ "$OVERALL" = "success" ]; then
              EMOJI="âœ…"
              COLOR="good"
              TITLE="OK"
            else
              EMOJI="âŒ"
              COLOR="danger"
              TITLE="Failing"
            fi
          fi

          SUMMARY="Status: ${PASSED}/${TOTAL} passed | Duration: ${DURATION_S}s"
          if [ "$FAILED" != "0" ] && [ -n "$FAILED_PHASES" ]; then
            SUMMARY="$SUMMARY | Failed: $FAILED_PHASES"
          fi

          CURRENT_PATH="${OUTPUT_DIR}/monitor-heavy-status.json"
          GRID=""
          for phase_name in bucket-create storage-request-batch1 upload-batch1 file-delete-first5 storage-request-batch2 upload-batch2 file-delete-all10 bucket-delete; do
            phase_status=$(jq -r ".phases[] | select(.name == \"$phase_name\") | .status" "$CURRENT_PATH" 2>/dev/null)
            if [ "$phase_status" = "passed" ]; then
              icon="âœ“"
            elif [ "$phase_status" = "failed" ]; then
              icon="âœ—"
            else
              icon="â—‹"
            fi
            case "$phase_name" in
              "bucket-create") display="Bucket Create     " ;;
              "storage-request-batch1") display="Storage Req (B1)  " ;;
              "upload-batch1") display="Upload (B1)       " ;;
              "file-delete-first5") display="Delete Half      " ;;
              "storage-request-batch2") display="Storage Req (B2)  " ;;
              "upload-batch2") display="Upload (B2)       " ;;
              "file-delete-all10") display="Delete All       " ;;
              "bucket-delete") display="Bucket Delete     " ;;
            esac
            GRID="${GRID}${icon} ${display}    "
            case "$phase_name" in
              "upload-batch1"|"upload-batch2"|"bucket-delete") GRID="${GRID}\n" ;;
            esac
          done

          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d "{
              \"text\": \"$EMOJI Testnet Sentinel - Monitor Heavy ($NETWORK) $TITLE\",
              \"attachments\": [
                {
                  \"color\": \"$COLOR\",
                  \"fields\": [
                    { \"title\": \"Summary\", \"value\": \"$SUMMARY\", \"short\": false },
                    { \"title\": \"Stage Results\", \"value\": \"$GRID\", \"short\": false },
                    { \"title\": \"Info\", \"value\": \"Network: $NETWORK | <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View on GitHub>\", \"short\": false }
                  ],
                  \"footer\": \"Testnet Sentinel\",
                  \"ts\": $(date +%s)
                }
              ]
            }"

      - name: Fail job if monitor-heavy reported failure
        if: always()
        env:
          OUTPUT_DIR: ${{ inputs.output_dir }}
        run: |
          CURRENT_PATH="${OUTPUT_DIR}/monitor-heavy-status.json"
          if [ -f "$CURRENT_PATH" ]; then
            if jq -e '.overall == "failed"' "$CURRENT_PATH" >/dev/null; then
              echo "monitor-heavy reported failure"
              exit 1
            fi
          fi

